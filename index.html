<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Advanced Chess Bot</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background-color: #222;
      color: #eee;
    }
    canvas {
      border: 2px solid #555;
      background-color: #f0d9b5;
      display: block;
      margin: 20px auto;
    }
    #controls {
      margin-top: 10px;
    }
    #promotionDialog {
      position: absolute;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      padding: 10px;
      border: 2px solid #ccc;
      display: none;
    }
    #promotionDialog button {
      font-size: 18px;
      margin: 5px;
      padding: 5px 10px;
      cursor: pointer;
    }
    .firework {
      position: absolute;
      width: 8px;
      height: 8px;
      background: yellow;
      border-radius: 50%;
      animation: explode 1s ease-out forwards;
    }
    @keyframes explode {
      0% { transform: translate(0, 0); opacity: 1; }
      100% { transform: translate(var(--dx), var(--dy)); opacity: 0; }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
</head>
<body>
  <h1>Advanced Chess Bot</h1>
  <canvas id="board" width="480" height="480"></canvas>
  <div id="controls">
    <label for="difficulty">Difficulty:</label>
    <select id="difficulty">
      <option value="1">Easy</option>
      <option value="2">Medium</option>
      <option value="3"‼️!!!IMPOSSIBLE+++!!!‼️</option>
    </select>
    <button onclick="resetGame()">Reset</button>
  </div>
  <div id="promotionDialog">
    <p>Choose promotion:</p>
    <button onclick="promote('q')">Queen</button>
    <button onclick="promote('r')">Rook</button>
    <button onclick="promote('b')">Bishop</button>
    <button onclick="promote('n')">Knight</button>
  </div>
  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const squareSize = 60;
    let game = new Chess();
    const piecesImg = {};
    let selected = null;
    let legalMoves = [];
    let pendingPromotion = null;
    let stockfishWorker = null;

    function initStockfish() {
      stockfishWorker = new Worker('https://cdn.jsdelivr.net/npm/stockfish@16.1.0/src/stockfish-nnue-16.js');
    }

    function drawBoard() {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const isLight = (r + c) % 2 === 0;
          ctx.fillStyle = isLight ? '#f0d9b5' : '#b58863';
          ctx.fillRect(c * squareSize, r * squareSize, squareSize, squareSize);
        }
      }

      if (selected) {
        ctx.strokeStyle = '#00f';
        ctx.lineWidth = 3;
        ctx.strokeRect(selected.col * squareSize, selected.row * squareSize, squareSize, squareSize);

        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
        for (const move of legalMoves) {
          const to = algebraicToCoords(move.to);
          ctx.beginPath();
          ctx.arc(to.col * squareSize + squareSize / 2, to.row * squareSize + squareSize / 2, 10, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }

    function drawPieces() {
      const board = game.board();
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece) {
            const img = piecesImg[piece.color + piece.type];
            if (img) {
              ctx.drawImage(img, c * squareSize, r * squareSize, squareSize, squareSize);
            }
          }
        }
      }
    }

    function render() {
      drawBoard();
      drawPieces();
    }

    function loadPieceImages(callback) {
      const types = ['p','r','n','b','q','k'];
      const colors = ['w','b'];
      let loaded = 0;
      for (let color of colors) {
        for (let type of types) {
          const img = new Image();
          const key = color + type;
          img.src = `https://images.chesscomfiles.com/chess-themes/pieces/neo/60/${key}.png`;
          img.onload = () => {
            piecesImg[key] = img;
            loaded++;
            if (loaded === 12) callback();
          };
        }
      }
    }

    function coordsToAlgebraic(square) {
      const files = 'abcdefgh';
      const ranks = '87654321';
      return files[square.col] + ranks[square.row];
    }

    function algebraicToCoords(square) {
      const files = 'abcdefgh';
      const ranks = '87654321';
      return {
        col: files.indexOf(square[0]),
        row: ranks.indexOf(square[1])
      };
    }

    function getSquare(x, y) {
      const col = Math.floor(x / squareSize);
      const row = Math.floor(y / squareSize);
      return { col, row };
    }

    function resetGame() {
      game = new Chess();
      selected = null;
      legalMoves = [];
      pendingPromotion = null;
      document.getElementById("promotionDialog").style.display = "none";
      render();
    }

    function evaluateEasy(board) {
      let score = 0;
      const values = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      const state = board.board();
      for (let row of state) {
        for (let piece of row) {
          if (piece) {
            const value = values[piece.type];
            score += piece.color === 'w' ? -value : value;
          }
        }
      }
      return score;
    }

    function evaluateMedium(board) {
      let score = evaluateEasy(board);
      const history = board.history({ verbose: true });
      let rookSwings = 0;
      let rookLast = {};
      let earlyRookPenalty = 0;
      let earlyMinorBonus = 0;
      for (let i = 0; i < history.length; i++) {
        const move = history[i];
        if (move.color === 'b') {
          if (move.piece === 'r') {
            if (i < 10) earlyRookPenalty += 2;
            const pair = move.from + '-' + move.to;
            const reverse = move.to + '-' + move.from;
            if (rookLast[reverse]) rookSwings++;
            rookLast[pair] = true;
          }
          if ((move.piece === 'n' || move.piece === 'b') && i < 10) {
            earlyMinorBonus += 0.5;
          }
        }
      }
      score -= rookSwings * 5;
      score -= earlyRookPenalty;
      score += earlyMinorBonus;
      return score;
    }

    function minimax(depth, isMax, diff) {
      if (depth === 0 || game.game_over()) {
        return diff === 1 ? evaluateEasy(game) : evaluateMedium(game);
      }

      const moves = game.moves();
      let bestScore = isMax ? -Infinity : Infinity;

      for (let move of moves) {
        game.move(move);
        let score = minimax(depth - 1, !isMax, diff);
        game.undo();
        bestScore = isMax ? Math.max(score, bestScore) : Math.min(score, bestScore);
      }
      return bestScore;
    }

    function botMove() {
      if (game.game_over()) return showFireworks();
      const diff = parseInt(document.getElementById('difficulty').value);
      if (diff === 3) return botMoveStockfish();

      const moves = game.moves();
      let best = [], bestScore = -Infinity;

      for (let move of moves) {
        game.move(move);
        let score = minimax(diff, false, diff);
        game.undo();
        if (score > bestScore) {
          bestScore = score;
          best = [move];
        } else if (score === bestScore) {
          best.push(move);
        }
      }

      const move = best[Math.floor(Math.random() * best.length)];
      setTimeout(() => {
        game.move(move);
        render();
        if (game.game_over()) showFireworks();
      }, 200);
    }

    function botMoveStockfish() {
      const fen = game.fen();
      stockfishWorker.postMessage('uci');
      stockfishWorker.postMessage('ucinewgame');
      stockfishWorker.postMessage(`position fen ${fen}`);
      stockfishWorker.postMessage('go movetime 300');

      stockfishWorker.onmessage = function(event) {
        const line = event.data;
        if (line.startsWith('bestmove')) {
          const bestMove = line.split(' ')[1];
          if (bestMove && bestMove !== '(none)') {
            const from = bestMove.slice(0, 2);
            const to = bestMove.slice(2, 4);
            const promotion = bestMove.length > 4 ? bestMove[4] : undefined;

            game.move({ from, to, promotion });
            render();
            if (game.game_over()) showFireworks();
          }
        }
      };
    }

    function promote(piece) {
      if (pendingPromotion) {
        const moveStr = coordsToAlgebraic(pendingPromotion.from) + coordsToAlgebraic(pendingPromotion.to);
        game.move({ from: moveStr.slice(0, 2), to: moveStr.slice(2, 4), promotion: piece });
        pendingPromotion = null;
        document.getElementById("promotionDialog").style.display = "none";
        render();
        if (game.game_over()) showFireworks();
        else setTimeout(botMove, 300);
      }
    }

    function showFireworks() {
      for (let i = 0; i < 20; i++) {
        const spark = document.createElement('div');
        spark.className = 'firework';
        spark.style.left = `${Math.random() * 480}px`;
        spark.style.top = `${Math.random() * 480}px`;
        spark.style.setProperty('--dx', `${(Math.random() - 0.5) * 200}px`);
        spark.style.setProperty('--dy', `${(Math.random() - 0.5) * 200}px`);
        document.body.appendChild(spark);
        setTimeout(() => spark.remove(), 1000);
      }
    }

    canvas.addEventListener('click', e => {
      if (game.turn() !== 'w') return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const square = getSquare(x, y);
      const fromAlg = selected ? coordsToAlgebraic(selected) : null;
      const toAlg = coordsToAlgebraic(square);
      const allMoves = game.moves({ verbose: true });

      if (!selected) {
        const moves = game.moves({ square: toAlg, verbose: true });
        if (moves.length > 0) {
          selected = square;
          legalMoves = moves;
          render();
        }
      } else {
        const move = allMoves.find(m => m.from === fromAlg && m.to === toAlg);
        if (move) {
          if (move.promotion) {
            pendingPromotion = { from: selected, to: square };
            document.getElementById("promotionDialog").style.display = "block";
          } else {
            game.move(move);
            selected = null;
            legalMoves = [];
            render();
            if (game.game_over()) showFireworks();
            else setTimeout(botMove, 300);
          }
        } else {
          selected = null;
          legalMoves = [];
          render();
        }
      }
    });

    loadPieceImages(() => {
      render();
      initStockfish(); // ✅ Initialize directly from URL
    });
  </script>
</body>
</html>

